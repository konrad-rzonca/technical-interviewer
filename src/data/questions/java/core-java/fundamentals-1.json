{
  "category": "Core Java",
  "subcategory": "Fundamentals",
  "questions": [
    {
      "id": "java-inheritance-vs-composition-core-java-f-8",
      "skillLevel": "intermediate",
      "shortTitle": "Inheritance vs Composition",
      "question": "You're designing a music player app with different types of audio content. How would you decide between inheritance and composition for your class structure?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "Inheritance for Audio Content Types",
              "description": "```java\n// Use inheritance when there's an \"is-a\" relationship\npublic abstract class AudioContent {\n    private String title;\n    private int durationInSeconds;\n    private String creator;\n    \n    public abstract void play();\n    public abstract void pause();\n}\n\n// Song is-a AudioContent\npublic class Song extends AudioContent {\n    private String album;\n    private String genre;\n    \n    @Override\n    public void play() { /* Song-specific playback */ }\n}\n\n// Podcast is-a AudioContent\npublic class Podcast extends AudioContent {\n    private int episodeNumber;\n    private String seriesName;\n    \n    @Override\n    public void play() { /* Podcast-specific playback */ }\n}\n```"
            },
            {
              "title": "Composition for Features and Capabilities",
              "description": "```java\n// Use composition for \"has-a\" relationships\npublic class MusicPlayer {\n    // Player has-a playlist, has-an audio engine\n    private Playlist currentPlaylist;        // Composition\n    private AudioEngine audioEngine;         // Composition\n    private EqualizerSettings equalizer;     // Composition\n    \n    public void playContent(AudioContent content) {\n        audioEngine.process(content, equalizer);\n    }\n}\n\n// AudioContent has-a PlaybackStrategy (more flexible than inheritance)\npublic class Song {\n    private String title;\n    private PlaybackStrategy playbackStrategy;  // Composition\n    \n    public void play() {\n        // Delegate to the strategy\n        playbackStrategy.play(this);\n    }\n    \n    // Can swap strategies at runtime\n    public void setPlaybackStrategy(PlaybackStrategy strategy) {\n        this.playbackStrategy = strategy;\n    }\n}\n```"
            },
            {
              "title": "Composition for Extensibility",
              "description": "```java\n// Composition makes it easy to add new features\npublic class AudioContent {\n    private String title;\n    private List<ContentFeature> features = new ArrayList<>();  // Composition\n    \n    // Add features dynamically\n    public void addFeature(ContentFeature feature) {\n        features.add(feature);\n    }\n    \n    // Check for specific features\n    public boolean hasFeature(Class<? extends ContentFeature> featureType) {\n        return features.stream()\n            .anyMatch(feature -> featureType.isInstance(feature));\n    }\n}\n\n// Create different feature implementations\npublic class OfflinePlaybackFeature implements ContentFeature { /* ... */ }\npublic class LyricsFeature implements ContentFeature { /* ... */ }\npublic class VisualizerFeature implements ContentFeature { /* ... */ }\n\n// Usage\nSong song = new Song(\"My Song\");\n// We can add any combination of features\nsong.addFeature(new OfflinePlaybackFeature());\nsong.addFeature(new LyricsFeature());\n```"
            },
            {
              "title": "Hybrid Approach",
              "description": "```java\n// Often best to use both approaches together\n\n// Inheritance for the content type hierarchy\npublic abstract class AudioContent { /* ... */ }\npublic class Song extends AudioContent { /* ... */ }\npublic class Podcast extends AudioContent { /* ... */ }\n\n// Composition for the player features\npublic class MusicPlayer {\n    // Components that can be swapped\n    private PlaybackEngine engine;         // Composition\n    private UserInterface ui;              // Composition\n    private AudioLibrary library;          // Composition\n    \n    // Switch playback mode at runtime\n    public void setPlaybackMode(PlaybackMode mode) {\n        switch (mode) {\n            case OFFLINE -> engine.setStrategy(new OfflinePlaybackStrategy());\n            case STREAMING -> engine.setStrategy(new StreamingPlaybackStrategy());\n            case HI_FIDELITY -> engine.setStrategy(new HiFiPlaybackStrategy());\n        }\n    }\n}\n```"
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "Inheritance Limitations",
              "description": "```java\n// Inheritance creates a rigid hierarchy\npublic class AudioBook extends AudioContent { /* ... */ }\n\n// What if we have interactive audio that's both a book and podcast?\n// Java doesn't support multiple inheritance\n// public class InteractiveAudioStory extends AudioBook, Podcast { /* ... */ }\n\n// Composition solves this cleanly\npublic class InteractiveContent {\n    private AudioContent baseContent;            // Composition\n    private InteractiveElements interactions;     // Composition\n    private NarrationEngine narrator;            // Composition\n    \n    // Can combine behaviors from different sources\n    public void play() {\n        narrator.start();\n        baseContent.play();\n        interactions.activate();\n    }\n}\n```"
            },
            {
              "title": "Testing Considerations",
              "description": "```java\n// Inheritance makes testing harder\npublic abstract class BasePlayer {\n    protected abstract AudioContent getCurrentContent();\n    \n    public void play() {\n        AudioContent content = getCurrentContent();  // Hard to test - depends on subclass\n        content.play();\n    }\n}\n\n// Composition is easier to test\npublic class Player {\n    private PlaybackEngine engine;  // Can mock this in tests\n    \n    public void play(AudioContent content) {\n        engine.play(content);\n    }\n    \n    // Dependency injection for testing\n    public void setEngine(PlaybackEngine engine) {\n        this.engine = engine;\n    }\n}\n```"
            },
            {
              "title": "Changing Behavior at Runtime",
              "description": "```java\n// With inheritance, behavior is fixed at compile time\npublic class StandardSong extends Song { /* fixed behavior */ }\npublic class HighQualitySong extends Song { /* fixed behavior */ }\n\n// With composition, behavior can change dynamically\npublic class Song {\n    private PlaybackQuality quality;\n    \n    // Change quality at runtime based on network conditions\n    public void adaptToNetworkCondition(NetworkStatus status) {\n        if (status == NetworkStatus.LIMITED) {\n            quality = PlaybackQuality.LOW;\n        } else if (status.getBandwidth() > 10) {\n            quality = PlaybackQuality.HIGH;\n        } else {\n            quality = PlaybackQuality.MEDIUM;\n        }\n    }\n}\n```"
            },
            {
              "title": "Encapsulating Variation",
              "description": "```java\n// Each content type needs different metadata\n\n// Inheritance approach - metadata methods spread throughout hierarchy\npublic abstract class AudioContent {\n    public abstract Map<String, String> getMetadata();\n}\n\npublic class Song extends AudioContent {\n    private String artist;\n    private String album;\n    \n    @Override\n    public Map<String, String> getMetadata() {  // Song-specific implementation\n        Map<String, String> metadata = new HashMap<>();\n        metadata.put(\"artist\", artist);\n        metadata.put(\"album\", album);\n        return metadata;\n    }\n}\n\n// Composition approach - metadata handlers encapsulated\npublic class AudioContent {\n    private MetadataProvider metadataProvider;  // Strategy pattern\n    \n    public Map<String, String> getMetadata() {\n        return metadataProvider.getMetadata();\n    }\n}\n\n// Different implementations for different content types\npublic class SongMetadataProvider implements MetadataProvider { /* ... */ }\npublic class PodcastMetadataProvider implements MetadataProvider { /* ... */ }\n```"
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Evolution and Maintenance",
              "description": "```java\n// Inheritance is harder to evolve\npublic abstract class AudioContent {\n    // Adding a new method forces all subclasses to implement it\n    public abstract void generateThumbnail();\n}\n\n// Composition is easier to evolve\npublic class AudioContent {\n    private List<ContentFeature> features = new ArrayList<>();\n    \n    // New features can be added without changing existing classes\n    public void addFeature(ContentFeature feature) {\n        features.add(feature);\n    }\n}\n\n// Add new feature later without modifying AudioContent\npublic class ThumbnailGenerator implements ContentFeature {\n    public void generateThumbnail(AudioContent content) { /* ... */ }\n}\n\n// Existing content works with new feature\nexistingContent.addFeature(new ThumbnailGenerator());\n```"
            },
            {
              "title": "Decorator Pattern with Composition",
              "description": "```java\n// Composition enables the decorator pattern\npublic interface AudioStream {\n    byte[] getNextChunk();\n    boolean hasMoreData();\n}\n\n// Base implementation\npublic class BasicAudioStream implements AudioStream { /* ... */ }\n\n// Decorators add behavior through composition\npublic class BufferedAudioStream implements AudioStream {\n    private final AudioStream wrapped;  // Composition\n    private final byte[] buffer;\n    \n    public BufferedAudioStream(AudioStream stream) {\n        this.wrapped = stream;\n        this.buffer = new byte[8192];\n    }\n    \n    @Override\n    public byte[] getNextChunk() {\n        // Add buffering behavior to any stream\n        if (bufferIsEmpty()) {\n            fillBuffer(wrapped.getNextChunk());\n        }\n        return getFromBuffer();\n    }\n}\n\n// Stack decorators to add multiple behaviors\nAudioStream stream = new EncryptedAudioStream(\n                      new CompressedAudioStream(\n                        new BufferedAudioStream(\n                          new BasicAudioStream(file))));\n```"
            },
            {
              "title": "Interface Segregation",
              "description": "```java\n// With inheritance, interfaces become bloated\npublic interface FullFeaturedAudioContent {\n    void play();\n    void pause();\n    byte[] getAudioData();\n    Map<String, String> getMetadata();\n    void displayLyrics();         // Not all content has lyrics\n    void showAlbumArt();          // Not all content has album art\n    void loadRelatedContent();    // Not all content has related content\n}\n\n// With composition + interfaces, each feature is separate\npublic interface Playable {\n    void play();\n    void pause();\n}\n\npublic interface HasMetadata {\n    Map<String, String> getMetadata();\n}\n\npublic interface HasLyrics {\n    String getLyrics();\n    void displayLyrics();\n}\n\n// Classes implement only what they need\npublic class Song implements Playable, HasMetadata, HasLyrics { /* ... */ }\npublic class Podcast implements Playable, HasMetadata { /* ... */ }  // No lyrics\n\n// Utility code can work with any combination\npublic void displayInfo(HasMetadata content) { /* ... */ }\npublic void addToPlaylist(Playable content) { /* ... */ }\n```"
            }
          ]
        }
      ]
    },
    {
      "id": "java-constructors-core-java-f-10",
      "skillLevel": "basic",
      "shortTitle": "Constructors",
      "question": "When creating a User class for your application, how would you design its constructors to handle different ways users might be created?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "Multiple Constructor Options",
              "description": "For a User class, you would typically create several constructors to handle different creation scenarios:\n```java\npublic class User {\n    private String username;\n    private String email;\n    private String fullName;\n    private boolean active;\n    \n    // Minimal constructor for quick creation\n    public User(String username, String email) {\n        this.username = username;\n        this.email = email;\n        this.active = true; // Default value\n    }\n    \n    // Full constructor with all fields\n    public User(String username, String email, String fullName, boolean active) {\n        this.username = username;\n        this.email = email;\n        this.fullName = fullName;\n        this.active = active;\n    }\n}\n```"
            },
            {
              "title": "Constructor Chaining",
              "description": "You can use constructor chaining to avoid code duplication and ensure consistent initialization:\n```java\npublic class User {\n    private String username;\n    private String email;\n    private String fullName;\n    private boolean active;\n    \n    // Minimal constructor\n    public User(String username, String email) {\n        this(username, email, null, true); // Call the full constructor\n    }\n    \n    // Full constructor with all fields\n    public User(String username, String email, String fullName, boolean active) {\n        this.username = username;\n        this.email = email;\n        this.fullName = fullName;\n        this.active = active;\n    }\n}\n```"
            },
            {
              "title": "Validation in Constructors",
              "description": "User constructors should validate input parameters to maintain data integrity:\n```java\npublic User(String username, String email) {\n    if (username == null || username.trim().isEmpty()) {\n        throw new IllegalArgumentException(\"Username cannot be empty\");\n    }\n    if (email == null || !email.contains(\"@\")) {\n        throw new IllegalArgumentException(\"Invalid email address\");\n    }\n    this.username = username;\n    this.email = email;\n    this.active = true;\n}\n```"
            },
            {
              "title": "Default Values",
              "description": "Establish sensible defaults for optional fields that aren't provided in simpler constructors:\n```java\npublic User(String username, String email) {\n    this.username = username;\n    this.email = email;\n    this.fullName = username; // Default to username if full name not provided\n    this.active = true;      // New users are active by default\n    this.createdDate = new Date(); // Automatically set creation timestamp\n}\n```"
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "Static Factory Methods",
              "description": "For a User class, static factory methods can provide more expressive alternatives to constructors:\n```java\npublic class User {\n    // Private constructor used by factory methods\n    private User(String username, String email, String fullName, boolean active) {\n        // Initialize fields\n    }\n    \n    // Factory method for regular user creation\n    public static User createStandardUser(String username, String email) {\n        return new User(username, email, null, true);\n    }\n    \n    // Factory method for admin user creation\n    public static User createAdminUser(String username, String email) {\n        User admin = new User(username, email, null, true);\n        admin.setRoles(Collections.singleton(\"ADMIN\"));\n        return admin;\n    }\n}\n```"
            },
            {
              "title": "Copy Constructor",
              "description": "A copy constructor is useful for creating a new User based on an existing one:\n```java\npublic User(User otherUser) {\n    this.username = otherUser.username;\n    this.email = otherUser.email;\n    this.fullName = otherUser.fullName;\n    this.active = otherUser.active;\n    this.roles = new HashSet<>(otherUser.roles); // Deep copy of collections\n}\n\n// Usage\nUser originalUser = new User(\"john\", \"john@example.com\");\nUser newUser = new User(originalUser); // Create a copy\n```"
            },
            {
              "title": "Builder Pattern Integration",
              "description": "For a User class with many optional fields, a builder pattern can work with a private constructor:\n```java\npublic class User {\n    private final String username; // Required\n    private final String email;    // Required\n    private String fullName;       // Optional\n    private boolean active;        // Optional\n    \n    private User(Builder builder) {\n        this.username = builder.username;\n        this.email = builder.email;\n        this.fullName = builder.fullName;\n        this.active = builder.active;\n    }\n    \n    public static class Builder {\n        // Required parameters\n        private final String username;\n        private final String email;\n        \n        // Optional parameters with defaults\n        private String fullName = \"\";\n        private boolean active = true;\n        \n        public Builder(String username, String email) {\n            this.username = username;\n            this.email = email;\n        }\n        \n        public Builder fullName(String fullName) {\n            this.fullName = fullName;\n            return this;\n        }\n        \n        public Builder active(boolean active) {\n            this.active = active;\n            return this;\n        }\n        \n        public User build() {\n            return new User(this);\n        }\n    }\n}\n\n// Usage\nUser user = new User.Builder(\"john\", \"john@example.com\")\n    .fullName(\"John Smith\")\n    .active(true)\n    .build();\n```"
            },
            {
              "title": "Converting from DTOs or External Sources",
              "description": "Special constructors can convert from DTOs or external data formats:\n```java\npublic class User {\n    // Fields...\n    \n    // Constructor from UserDTO\n    public User(UserDTO dto) {\n        this.username = dto.getUsername();\n        this.email = dto.getEmail();\n        this.fullName = dto.getFirstName() + \" \" + dto.getLastName();\n        this.active = true;\n    }\n    \n    // Constructor from JSON\n    public User(JSONObject json) {\n        this.username = json.getString(\"username\");\n        this.email = json.getString(\"email\");\n        this.fullName = json.optString(\"fullName\", null);\n        this.active = json.optBoolean(\"active\", true);\n    }\n}\n```"
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Dependency Injection",
              "description": "Advanced User classes might require dependencies like services in constructors:\n```java\npublic class User {\n    private String username;\n    private String email;\n    private final UserActivityService activityService;\n    \n    // Constructor with dependency injection\n    public User(String username, String email, UserActivityService activityService) {\n        this.username = username;\n        this.email = email;\n        this.activityService = activityService;\n    }\n    \n    public void login() {\n        // Use injected service\n        activityService.recordLogin(this.username);\n    }\n}\n```"
            },
            {
              "title": "Lazy Initialization",
              "description": "Some User properties may be expensive to initialize and can be deferred until needed:\n```java\npublic class User {\n    private String username;\n    private String email;\n    private volatile UserPreferences preferences;\n    private final Object preferencesLock = new Object();\n    \n    public User(String username, String email) {\n        this.username = username;\n        this.email = email;\n        // Preferences are expensive to load, so we'll defer initialization\n    }\n    \n    public UserPreferences getPreferences() {\n        if (preferences == null) {\n            synchronized (preferencesLock) {\n                if (preferences == null) {\n                    preferences = UserPreferencesLoader.loadForUser(username);\n                }\n            }\n        }\n        return preferences;\n    }\n}\n```"
            },
            {
              "title": "Domain-Specific Validation Logic",
              "description": "Advanced User constructors may include complex validation logic or business rules:\n```java\npublic User(String username, String email, String password, Role role) {\n    // Basic validation\n    validateBasicFields(username, email);\n    \n    // Password strength validation\n    if (password.length() < 8 || !containsDigit(password) || !containsSpecialChar(password)) {\n        throw new WeakPasswordException(\"Password does not meet security requirements\");\n    }\n    \n    // Role-based validation\n    if (role == Role.ADMIN && !isEmailFromCompanyDomain(email)) {\n        throw new SecurityException(\"Admin users must use company email addresses\");\n    }\n    \n    // Initialize with encrypted password\n    this.username = username;\n    this.email = email;\n    this.passwordHash = passwordEncoder.encode(password);\n    this.role = role;\n}\n```"
            },
            {
              "title": "Immutability Pattern",
              "description": "For secure User representations, use constructors to create immutable instances:\n```java\npublic final class ImmutableUser {\n    private final String username;\n    private final String email;\n    private final Set<String> roles;\n    \n    public ImmutableUser(String username, String email, Set<String> roles) {\n        this.username = username;\n        this.email = email;\n        // Create defensive copy of mutable collections\n        this.roles = Collections.unmodifiableSet(new HashSet<>(roles));\n    }\n    \n    // Only getters, no setters\n    public String getUsername() { return username; }\n    public String getEmail() { return email; }\n    public Set<String> getRoles() { return roles; } // Returns unmodifiable view\n    \n    // To modify, create a new instance\n    public ImmutableUser withEmail(String newEmail) {\n        return new ImmutableUser(this.username, newEmail, this.roles);\n    }\n}\n```"
            }
          ]
        }
      ],
      "relatedQuestions": [
        "java-object-creation-core-java-f-11"
      ]
    },
    {
      "id": "java-object-creation-core-java-f-11",
      "skillLevel": "intermediate",
      "shortTitle": "Object Creation",
      "question": "What are the different ways to create objects in Java?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "Using new Keyword",
              "description": "The most common way to create an object is using the **new** keyword, which allocates memory for the object and invokes a constructor: `ClassName object = new ClassName()`."
            },
            {
              "title": "Using Factory Methods",
              "description": "**Factory methods** are static methods that return an instance of the class. They provide an alternative to constructors, often with more meaningful names and flexibility: `Integer value = Integer.valueOf(42)`."
            },
            {
              "title": "Using Constructors with Arguments",
              "description": "Objects can be created with initial state by passing arguments to constructors: `Person person = new Person(\"John\", 30)`."
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "Using clone() Method",
              "description": "The **clone()** method creates a copy of an existing object. The class must implement the `Cloneable` interface and override the `clone()` method: `Person clonedPerson = (Person) originalPerson.clone()`."
            },
            {
              "title": "Using Deserialization",
              "description": "**Deserialization** recreates objects from their serialized form, useful for persisting objects or transferring them over a network: \n```java\nObjectInputStream in = new ObjectInputStream(new FileInputStream(\"object.ser\"));\nPerson person = (Person) in.readObject();\n```"
            },
            {
              "title": "Using newInstance() Method",
              "description": "The **Class.newInstance()** method (deprecated in Java 9) or **Constructor.newInstance()** creates an object by dynamically loading a class and invoking its no-arg constructor: \n```java\nClass<?> clazz = Class.forName(\"com.example.Person\");\nPerson person = (Person) clazz.getDeclaredConstructor().newInstance();\n```"
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Using Builder Pattern",
              "description": "The **Builder Pattern** creates objects step by step, especially useful for objects with many optional parameters: \n```java\nPerson person = new Person.Builder()\n    .withName(\"John\")\n    .withAge(30)\n    .withAddress(\"123 Main St\")\n    .build();\n```"
            },
            {
              "title": "Using Object Serialization Framework",
              "description": "**Object serialization frameworks** like Jackson or Gson can create objects from JSON, XML, or other formats: \n```java\nObjectMapper mapper = new ObjectMapper();\nPerson person = mapper.readValue(jsonString, Person.class);\n```"
            },
            {
              "title": "Using Dependency Injection",
              "description": "**Dependency Injection frameworks** like Spring can create and manage objects for you, handling their lifecycles and dependencies: \n```java\n@Component\nclass PersonService { ... }\n\n// In another class:\n@Autowired\nprivate PersonService personService; // Spring creates and injects the object\n```"
            }
          ]
        }
      ],
      "relatedQuestions": [
        "java-constructors-core-java-f-10"
      ]
    },
    {
      "id": "java-method-overloading-overriding-core-java-f-12",
      "skillLevel": "basic",
      "shortTitle": "Overloading vs Overriding",
      "question": "Could you explain the difference between method overloading and method overriding in Java?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "Method Overloading",
              "description": "**Method overloading** occurs when multiple methods in the same class have the same name but different parameter lists (different number or types of parameters). It's a compile-time polymorphism feature."
            },
            {
              "title": "Method Overriding",
              "description": "**Method overriding** occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. The method must have the same name, return type (or covariant return type), and parameter list."
            },
            {
              "title": "Basic Difference",
              "description": "Overloading is about multiple methods with the same name in the same class, while overriding is about replacing a superclass method in a subclass."
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "Overloading Rules",
              "description": "For overloading, methods must differ in the number, type, or order of parameters. Changing only the return type or access modifier does not constitute overloading."
            },
            {
              "title": "Overriding Rules",
              "description": "For overriding, the method signature must be the same. The overriding method cannot have a more restrictive access modifier, but it can have a less restrictive one. It can throw fewer or narrower checked exceptions."
            },
            {
              "title": "@Override Annotation",
              "description": "The `@Override` annotation is used to mark methods that override a superclass method. It's optional but recommended as it helps the compiler catch errors if the method doesn't actually override anything."
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Covariant Return Types",
              "description": "Since Java 5, an overriding method can return a subtype of the return type declared in the superclass method (covariant return type).\n```java\nclass Animal { Animal getOffspring() { ... } }\nclass Dog extends Animal { @Override Dog getOffspring() { ... } } // Dog is a subtype of Animal\n```"
            },
            {
              "title": "Static Method Behavior",
              "description": "Static methods can be overloaded but cannot be overridden. If a subclass defines a static method with the same signature as a static method in the superclass, it **hides** rather than overrides the superclass method."
            },
            {
              "title": "Bridge Methods",
              "description": "When working with generics and covariant return types, the Java compiler sometimes creates **bridge methods** to maintain binary compatibility. These are synthetic methods that handle the method dispatch correctly."
            }
          ]
        }
      ],
      "relatedQuestions": [
        "java-polymorphism-core-java-f-13"
      ]
    },
    {
      "id": "java-static-keyword-core-java-f-14",
      "skillLevel": "basic",
      "shortTitle": "Static Keyword",
      "question": "What are the various uses of the 'static' keyword in Java?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "Static Variables",
              "description": "**Static variables** (class variables) are shared among all instances of a class. They're created when the class is loaded and exist until the program ends. They're accessed using the class name: `ClassName.variableName`."
            },
            {
              "title": "Static Methods",
              "description": "**Static methods** belong to the class rather than any instance. They can be called without creating an object, using the class name: `ClassName.methodName()`. They cannot access instance variables or methods directly."
            },
            {
              "title": "Static Blocks",
              "description": "**Static initialization blocks** are executed when the class is loaded, before any static methods are called or static variables are accessed. They're used for complex static initialization: \n```java\nstatic {\n    // Initialization code\n}\n```"
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "Static Import",
              "description": "**Static import** allows you to access static members of a class without class qualification. It can be used for individual members or all static members: \n```java\nimport static java.lang.Math.PI; // Import a specific static field\nimport static java.lang.Math.*; // Import all static members\n\ndouble area = PI * radius * radius; // Use PI directly without Math.\n```"
            },
            {
              "title": "Static Nested Classes",
              "description": "A **static nested class** is a nested class that is a static member of the outer class. Unlike inner classes, it doesn't have access to the instance members of the outer class, and it can be instantiated without an outer class instance: \n```java\nclass Outer {\n    static class Nested { ... }\n}\nOuter.Nested instance = new Outer.Nested();\n```"
            },
            {
              "title": "Static Constants",
              "description": "**Static final** variables are constants that are the same for all instances. They're often declared as `public static final` to make them accessible from outside the class while ensuring they cannot be changed: \n```java\npublic static final double PI = 3.14159265359;\n```"
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Static Factory Methods",
              "description": "**Static factory methods** are static methods that return an instance of the class. They provide alternatives to constructors with benefits such as more descriptive names, caching, and subtype returns: \n```java\npublic static Integer valueOf(int i) { ... }\n```"
            },
            {
              "title": "Memory Management",
              "description": "Static members are stored in the method area of JVM memory, not the heap where objects are stored. This means they persist for the entire program execution, which can be a memory concern if large static data structures are used."
            },
            {
              "title": "Static Context Limitations",
              "description": "The **static context** has important limitations: you cannot use `this` or `super` keywords, cannot access instance variables or methods directly, and cannot override static methods (though they can be hidden by a subclass method with the same signature)."
            }
          ]
        }
      ],
      "relatedQuestions": [
        "java-final-keyword-core-java-f-15"
      ]
    },
    {
      "id": "java-final-keyword-core-java-f-15",
      "skillLevel": "basic",
      "shortTitle": "Final Keyword",
      "question": "What are the different uses of the 'final' keyword in Java?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "Final Variables",
              "description": "A **final variable** can only be assigned once. Once initialized, its value cannot be changed. It can be a compile-time constant or assigned at runtime: \n```java\nfinal int MAX_SPEED = 120; // Compile-time constant\nfinal int id; // Can be assigned later, but only once\n```"
            },
            {
              "title": "Final Methods",
              "description": "A **final method** cannot be overridden by subclasses. This ensures that the method's behavior remains the same throughout all subclasses: \n```java\npublic final void processPayment() { ... }\n```"
            },
            {
              "title": "Final Classes",
              "description": "A **final class** cannot be subclassed (extended). This is used when a class's implementation should not be changed or extended, such as the `String` and `Math` classes in Java's standard library: \n```java\npublic final class ImmutableValue { ... }\n```"
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "Final Method Parameters",
              "description": "Method parameters declared as **final** cannot be modified within the method body, providing an additional level of safety: \n```java\npublic void process(final int value) {\n    // value = 10; // This would cause a compilation error\n}\n```"
            },
            {
              "title": "Final Object References",
              "description": "When a reference variable is declared as **final**, it means the reference cannot be changed to point to another object, but the object's internal state can still be modified if it's mutable: \n```java\nfinal List<String> list = new ArrayList<>();\nlist.add(\"Item\"); // Valid - changing the object's state\n// list = new ArrayList<>(); // Invalid - changing the reference\n```"
            },
            {
              "title": "Blank Final Variables",
              "description": "A **blank final variable** is a final variable that is not initialized at the time of declaration. It must be initialized in all constructors (for instance variables) or before it's first used (for local variables): \n```java\nclass Circle {\n    final double PI;\n    Circle() {\n        PI = 3.14159; // Must initialize in constructor\n    }\n}\n```"
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Final in Immutable Classes",
              "description": "**Immutable classes** are typically declared as final to prevent subclassing. All fields are declared private and final, and no mutator methods are provided. The `String` class is a prime example of an immutable class in Java."
            },
            {
              "title": "Final and Performance",
              "description": "The JVM can make certain optimizations with **final** methods and variables. Final methods can be inlined by the compiler, potentially improving performance. Final variables can be safely cached by the JVM."
            },
            {
              "title": "Effectively Final",
              "description": "Since Java 8, variables that are not explicitly declared as final but whose value never changes after initialization are considered **effectively final**. These can be used in lambda expressions or anonymous classes: \n```java\nString name = \"John\"; // Effectively final\nButtom button = new Button();\nbutton.setOnAction(event -> System.out.println(name)); // Valid because name is effectively final\n```"
            }
          ]
        }
      ],
      "relatedQuestions": [
        "java-static-keyword-core-java-f-14"
      ]
    },
    {
      "id": "java-wrapper-classes-core-java-f-16",
      "skillLevel": "basic",
      "shortTitle": "Wrapper Classes",
      "question": "What are wrapper classes in Java, and why are they needed?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "Definition",
              "description": "**Wrapper classes** provide object representations of primitive data types in Java. Each primitive type has a corresponding wrapper class: `Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, and `Boolean`."
            },
            {
              "title": "Purpose",
              "description": "Wrapper classes allow primitive values to be used in contexts that require objects, such as collections (like `ArrayList<Integer>` instead of `ArrayList<int>`), generics, and methods expecting object parameters."
            },
            {
              "title": "Creating Wrapper Objects",
              "description": "Wrapper objects can be created using constructors (deprecated in Java 9) or factory methods: \n```java\nInteger num1 = new Integer(42); // Deprecated\nInteger num2 = Integer.valueOf(42); // Preferred\n```"
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "Autoboxing and Unboxing",
              "description": "**Autoboxing** automatically converts primitives to their wrapper objects, while **unboxing** converts wrapper objects back to primitives: \n```java\nInteger wrappedInt = 42; // Autoboxing\nint primitive = wrappedInt; // Unboxing\n```"
            },
            {
              "title": "Utility Methods",
              "description": "Wrapper classes provide utility methods for parsing strings, converting between types, and working with values: \n```java\nInteger.parseInt(\"123\"); // String to int\nInteger.toString(123); // int to String\nInteger.toBinaryString(123); // int to binary string\n```"
            },
            {
              "title": "Caching",
              "description": "For efficiency, some wrapper classes cache commonly used values. For example, `Integer.valueOf()` caches values from -128 to 127, so multiple calls with the same value may return the same object."
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Performance Considerations",
              "description": "Frequent autoboxing and unboxing can impact performance, especially in tight loops or memory-constrained environments. Each wrapper object allocates memory on the heap, unlike primitives which are stored on the stack when used locally."
            },
            {
              "title": "Null Handling",
              "description": "Wrapper objects can be `null`, unlike primitives. This requires careful handling to avoid `NullPointerException` during unboxing: \n```java\nInteger nullInteger = null;\nint primitive = nullInteger; // Throws NullPointerException at runtime\n```"
            },
            {
              "title": "Immutability",
              "description": "All wrapper objects are **immutable**, meaning their state cannot be changed after creation. This allows safe sharing of common instances (like cached values) and makes them suitable for use as keys in hash-based collections."
            }
          ]
        }
      ],
      "relatedQuestions": [
        "java-autoboxing-unboxing-core-java-f-17"
      ]
    },
    {
      "id": "java-autoboxing-unboxing-core-java-f-17",
      "skillLevel": "basic",
      "shortTitle": "Autoboxing and Unboxing",
      "question": "Can you explain autoboxing and unboxing in Java and potential pitfalls?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "Autoboxing",
              "description": "**Autoboxing** is the automatic conversion of primitive data types to their corresponding wrapper classes. For example, `int` to `Integer` or `boolean` to `Boolean`: \n```java\nInteger number = 42; // Autoboxing: int → Integer\n```"
            },
            {
              "title": "Unboxing",
              "description": "**Unboxing** is the automatic conversion of wrapper objects back to their primitive types: \n```java\nInteger wrapper = Integer.valueOf(42);\nint primitive = wrapper; // Unboxing: Integer → int\n```"
            },
            {
              "title": "Common Usage",
              "description": "Autoboxing and unboxing occur automatically in assignments, method calls, and expressions, making code more readable and reducing the need for explicit conversions: \n```java\nList<Integer> numbers = new ArrayList<>();\nnumbers.add(10); // Autoboxing in method argument\nint sum = numbers.get(0) + 5; // Unboxing in expression\n```"
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "NullPointerException Risk",
              "description": "Unboxing a `null` wrapper object will cause a `NullPointerException`. This is a common runtime error when working with collections or databases that may contain null values: \n```java\nInteger nullValue = null;\nint primitive = nullValue; // Throws NullPointerException\n```"
            },
            {
              "title": "Performance Overhead",
              "description": "Autoboxing and unboxing introduce performance overhead, especially in tight loops or large collections, as they involve object creation and method calls: \n```java\nint sum = 0;\nfor (int i = 0; i < 1000000; i++) {\n    sum += Integer.valueOf(i); // Creates many objects unnecessarily\n}\n```"
            },
            {
              "title": "Collection Context",
              "description": "Since Java collections can only store objects, autoboxing enables primitive values to be easily added to collections: \n```java\nList<Integer> numbers = new ArrayList<>();\nnumbers.add(42); // Autoboxing happens here\n```"
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Equality Operator Pitfalls",
              "description": "The `==` operator compares object references for wrapper types, not their values, which can lead to unexpected results: \n```java\nInteger a = 127;\nInteger b = 127;\nSystem.out.println(a == b); // true (due to caching)\n\nInteger c = 128;\nInteger d = 128;\nSystem.out.println(c == d); // false (outside cache range)\n\n// Always use equals() for comparing wrapper objects\nSystem.out.println(c.equals(d)); // true\n```"
            },
            {
              "title": "Caching Behavior",
              "description": "Most wrapper classes cache common values to improve performance. For example, `Integer` caches values from -128 to 127, `Boolean` caches `TRUE` and `FALSE`, and `Character` caches values from 0 to 127. This behavior affects identity comparisons and can lead to subtle bugs."
            },
            {
              "title": "Generics and Type Erasure",
              "description": "Due to type erasure in generics, primitive types cannot be used as type parameters. Autoboxing enables working with generics while conceptually using primitive types: \n```java\n// Not possible: List<int> numbers = new ArrayList<>();\nList<Integer> numbers = new ArrayList<>(); // Works with autoboxing\n```"
            }
          ]
        }
      ],
      "relatedQuestions": [
        "java-wrapper-classes-core-java-f-16"
      ]
    },
    {
      "id": "java-string-pool-core-java-f-18",
      "skillLevel": "intermediate",
      "shortTitle": "String Pool",
      "question": "How does the String pool work in Java, and what are the implications for String comparison?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "String Pool Definition",
              "description": "The **String pool** (also called String constant pool or String intern pool) is a special area in Java's memory that stores unique string literals. It helps conserve memory by reusing string objects."
            },
            {
              "title": "String Literal Behavior",
              "description": "When a string literal is created (e.g., `String s = \"hello\"`), Java first checks if an identical string exists in the pool. If it does, the reference to that existing string is returned; otherwise, a new string is added to the pool."
            },
            {
              "title": "String Creation Methods",
              "description": "Strings created with the `new` keyword (e.g., `String s = new String(\"hello\")`) are always created as new objects in the heap, not in the String pool, even if an identical string exists in the pool."
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "intern() Method",
              "description": "The `intern()` method can be used to add a string to the pool if it doesn't exist there yet, or to get a reference to the pooled instance if it does: \n```java\nString s1 = new String(\"hello\"); // Creates in heap\nString s2 = s1.intern(); // Returns reference from pool (or adds it)\nString s3 = \"hello\"; // From pool\nSystem.out.println(s2 == s3); // true\n```"
            },
            {
              "title": "String Comparison",
              "description": "Using `==` compares object references, not string content. For strings from the pool, identical content means identical references, but this isn't true for strings created with `new`. Always use `equals()` for content comparison: \n```java\nString s1 = \"hello\";\nString s2 = \"hello\";\nString s3 = new String(\"hello\");\n\nSystem.out.println(s1 == s2); // true, same reference from pool\nSystem.out.println(s1 == s3); // false, different references\nSystem.out.println(s1.equals(s3)); // true, same content\n```"
            },
            {
              "title": "String Concatenation",
              "description": "When strings are concatenated with the `+` operator, the result depends on whether the values are known at compile-time: \n```java\nString s1 = \"hello\" + \"world\"; // Compile-time constant, goes into pool\nString s2 = \"hello\";\nString s3 = s2 + \"world\"; // Runtime concatenation, not pooled\nString s4 = \"helloworld\";\nSystem.out.println(s1 == s4); // true\nSystem.out.println(s3 == s4); // false\n```"
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Memory Location Changes",
              "description": "Before Java 7, the String pool was in the PermGen space, which had a fixed size. Since Java 7, it's located in the heap, allowing it to grow dynamically and benefit from garbage collection."
            },
            {
              "title": "Performance Implications",
              "description": "Using pooled strings reduces memory usage but can increase lookup time. The `intern()` method can be expensive for large strings or when called frequently. In high-performance applications, consider the trade-off between memory usage and CPU time."
            },
            {
              "title": "Security Considerations",
              "description": "String pooling can potentially lead to denial-of-service attacks if untrusted input is interned, filling the pool with many unique strings. Applications that handle large volumes of user-generated strings should be careful about using `intern()`."
            }
          ]
        }
      ],
      "relatedQuestions": [
        "java-string-vs-stringbuilder-core-java-f-19"
      ]
    },
    {
      "id": "java-string-vs-stringbuilder-core-java-f-19",
      "skillLevel": "basic",
      "shortTitle": "StringBuilder vs StringBuffer",
      "question": "Could you compare String, StringBuilder, and StringBuffer in Java?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "Mutability",
              "description": "**String** is immutable, meaning once created, its content cannot be changed. **StringBuilder** and **StringBuffer** are mutable, allowing character sequences to be modified without creating new objects."
            },
            {
              "title": "Thread Safety",
              "description": "**String** is immutable and thus thread-safe. **StringBuffer** is thread-safe due to synchronized methods, while **StringBuilder** is not thread-safe but offers better performance in single-threaded scenarios."
            },
            {
              "title": "Basic Usage",
              "description": "Use **String** for simple string values that won't change. Use **StringBuilder** for string manipulation in a single thread, and **StringBuffer** when multiple threads might modify the same string."
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "Performance",
              "description": "For concatenation operations, **String** performs poorly because each concatenation creates a new object. **StringBuilder** is much faster for multiple modifications, and **StringBuffer** is slower than StringBuilder due to synchronization overhead."
            },
            {
              "title": "Common Methods",
              "description": "Both **StringBuilder** and **StringBuffer** offer methods like `append()`, `insert()`, `delete()`, `reverse()`, and `replace()` for string manipulation. The API is virtually identical, but StringBuffer methods are synchronized."
            },
            {
              "title": "String Concatenation in Loops",
              "description": "Using **String** concatenation in loops is a common performance anti-pattern: \n```java\n// Inefficient\nString result = \"\";\nfor (int i = 0; i < 10000; i++) {\n    result += i; // Creates many intermediate String objects\n}\n\n// Efficient\nStringBuilder result = new StringBuilder();\nfor (int i = 0; i < 10000; i++) {\n    result.append(i); // Modifies the same StringBuilder object\n}\nString finalResult = result.toString();\n```"
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Memory Management",
              "description": "**StringBuilder** and **StringBuffer** manage an internal character array that grows as needed. The initial capacity can be specified to reduce reallocations. Both double their capacity when the buffer overflows, which can lead to memory inefficiency if the final size is much smaller than the capacity."
            },
            {
              "title": "Compiler Optimization",
              "description": "The Java compiler automatically optimizes **String** concatenation using **StringBuilder** in some cases, such as concatenation in a single statement: \n```java\nString s = \"a\" + \"b\" + \"c\"; // Compiler may optimize this to use StringBuilder\n```\nHowever, this optimization doesn't apply to concatenation across multiple statements or in loops."
            },
            {
              "title": "Performance Comparison",
              "description": "Performance benchmarks typically show:\n- **String** concatenation: Slowest for multiple operations due to immutability\n- **StringBuilder**: 5-10% faster than StringBuffer in single-threaded code\n- **StringBuffer**: Necessary when thread safety is required, despite the performance penalty\n\nThe choice should be based on the specific use case, considering thread safety requirements and the frequency of string modifications."
            }
          ]
        }
      ],
      "relatedQuestions": [
        "java-string-pool-core-java-f-18"
      ]
    },
    {
      "id": "java-enums-core-java-f-20",
      "skillLevel": "basic",
      "shortTitle": "Enums",
      "question": "You need to represent fixed categories of products in your e-commerce system. What advantages would enums provide over using string constants?",
      "answerInsights": [
        {
          "category": "Basic",
          "points": [
            {
              "title": "Type Safety",
              "description": "```java\n// With string constants - error-prone\npublic class ProductWithStrings {\n    // String constants\n    public static final String CATEGORY_ELECTRONICS = \"electronics\";\n    public static final String CATEGORY_CLOTHING = \"clothing\";\n    \n    private String category;  // Can be ANY string\n    \n    public void setCategory(String category) {\n        this.category = category;  // No validation!\n    }\n}\n\n// Typos aren't caught by compiler\nproduct.setCategory(\"eletronics\");  // Misspelled but compiles\nproduct.setCategory(\"invalid\");     // Not a valid category but compiles\n\n// With enums - type-safe\npublic enum ProductCategory {\n    ELECTRONICS, CLOTHING, BOOKS, TOYS\n}\n\npublic class Product {\n    private ProductCategory category;  // Can ONLY be a valid enum value\n    \n    public void setCategory(ProductCategory category) {\n        this.category = category;  // Type-safe - compiler prevents errors\n    }\n}\n\n// Won't compile if invalid\nproduct.setCategory(ProductCategory.ELECTRONICS);  // Valid\n// product.setCategory(\"electronics\");  // Compile error\n// product.setCategory(null);  // Allowed, but obvious\n```"
            },
            {
              "title": "Switch Statement Completeness",
              "description": "```java\n// Using strings - missing cases not detected\nswitch (product.getCategory()) {  // Returns a String\n    case \"electronics\":\n        applyElectronicsDiscount(product);\n        break;\n    case \"clothing\":\n        applyClothingDiscount(product);\n        break;\n    // Compiler can't warn about missing cases\n}\n\n// Using enums - compiler warns about missing cases\nswitch (product.getCategory()) {  // Returns a ProductCategory enum\n    case ELECTRONICS:\n        applyElectronicsDiscount(product);\n        break;\n    case CLOTHING:\n        applyClothingDiscount(product);\n        break;\n    // Compiler warns about missing BOOKS, TOYS\n}\n\n// Java 17+ pattern matching (more concise)\nswitch (product.getCategory()) {\n    case ELECTRONICS -> applyElectronicsDiscount(product);\n    case CLOTHING -> applyClothingDiscount(product);\n    case BOOKS -> applyBooksDiscount(product);\n    case TOYS -> applyToysDiscount(product);\n}\n```"
            },
            {
              "title": "Code Completion and IDE Support",
              "description": "```java\n// String constants - limited IDE help\nproduct.setCategory(ProductConstants.CATEGORY_);  // IDE lists all constants, not just categories\n\n// Enums - IDE shows all valid options\nproduct.setCategory(ProductCategory.);  // IDE shows ELECTRONICS, CLOTHING, etc.\n\n// Auto-completion and discoverability\nProductCategory category = ProductCategory.ELECTRONICS;\n\n// Built-in helper methods\nProductCategory[] allCategories = ProductCategory.values();\nProductCategory fromString = ProductCategory.valueOf(\"ELECTRONICS\");\nString name = ProductCategory.BOOKS.name();\nint ordinal = ProductCategory.TOYS.ordinal();  // Position in enum declaration (0-based)\n\n// Enum membership test\nif (category == ProductCategory.ELECTRONICS) {\n    // Safe comparison with ==\n}\n```"
            },
            {
              "title": "Namespace Protection",
              "description": "```java\n// String constants - potential naming conflicts\npublic static final String TYPE_BOOK = \"book\";  // Book product type\npublic static final String FORMAT_BOOK = \"book\";  // Book format type (vs eBook)\n\n// String comparison is ambiguous\nif (product.getType().equals(\"book\")) {  // Which \"book\" constant was intended?\n    // Handle book\n}\n\n// Enums prevent name collisions by namespace\npublic enum ProductType { PHYSICAL, DIGITAL, SUBSCRIPTION }\npublic enum ProductFormat { BOOK, EBOOK, AUDIOBOOK }\n\n// Type-safe and clear\nif (product.getType() == ProductType.PHYSICAL && \n    product.getFormat() == ProductFormat.BOOK) {\n    // Handle physical book\n}\n```"
            }
          ]
        },
        {
          "category": "Intermediate",
          "points": [
            {
              "title": "Adding Properties to Categories",
              "description": "```java\n// With string constants, need separate maps\npublic static final String CATEGORY_ELECTRONICS = \"electronics\";\npublic static final String CATEGORY_CLOTHING = \"clothing\";\n\n// Separate maps for different properties\nprivate static final Map<String, Double> CATEGORY_TAX_RATES = Map.of(\n    CATEGORY_ELECTRONICS, 0.085,\n    CATEGORY_CLOTHING, 0.055\n);\n\n// Must look up in map\ndouble taxRate = CATEGORY_TAX_RATES.get(product.getCategory());\n\n// With enums, properties are built-in\npublic enum ProductCategory {\n    ELECTRONICS(0.085, \"Tech\", true),\n    CLOTHING(0.055, \"Apparel\", true),\n    BOOKS(0.0, \"Media\", false),\n    GROCERY(0.03, \"Food\", false);\n    \n    private final double taxRate;\n    private final String department;\n    private final boolean requiresWarranty;\n    \n    // Constructor\n    ProductCategory(double taxRate, String department, boolean requiresWarranty) {\n        this.taxRate = taxRate;\n        this.department = department;\n        this.requiresWarranty = requiresWarranty;\n    }\n    \n    // Getters\n    public double getTaxRate() { return taxRate; }\n    public String getDepartment() { return department; }\n    public boolean requiresWarranty() { return requiresWarranty; }\n}\n\n// Access properties directly\ndouble taxRate = product.getCategory().getTaxRate();\nString dept = product.getCategory().getDepartment();\n```"
            },
            {
              "title": "Adding Behavior to Categories",
              "description": "```java\n// With strings, behavior must be in external methods\npublic double calculateTax(Product product) {\n    String category = product.getCategory();\n    double amount = product.getPrice();\n    \n    if (\"electronics\".equals(category)) {\n        return amount * 0.085;\n    } else if (\"clothing\".equals(category)) {\n        return amount * 0.055;\n    }\n    // More if/else conditions...\n    return 0;\n}\n\n// With enums, behavior is encapsulated\npublic enum ProductCategory {\n    ELECTRONICS {\n        @Override\n        public double calculateTax(double amount) {\n            return amount * 0.085;\n        }\n        \n        @Override\n        public boolean requiresShippingInsurance() {\n            return true;\n        }\n    },\n    CLOTHING {\n        @Override\n        public double calculateTax(double amount) {\n            return amount * 0.055;\n        }\n        \n        @Override\n        public boolean requiresShippingInsurance() {\n            return false;\n        }\n    },\n    BOOKS {\n        @Override\n        public double calculateTax(double amount) {\n            return 0; // Tax exempt\n        }\n        \n        @Override\n        public boolean requiresShippingInsurance() {\n            return false;\n        }\n    };\n    \n    // Abstract methods that each category must implement\n    public abstract double calculateTax(double amount);\n    public abstract boolean requiresShippingInsurance();\n}\n\n// Call methods directly on the enum\ndouble tax = product.getCategory().calculateTax(product.getPrice());\n```"
            },
            {
              "title": "Category Hierarchies",
              "description": "```java\n// Representing category hierarchy with enums\npublic enum ProductCategory {\n    // Main categories\n    ELECTRONICS(null),\n    CLOTHING(null),\n    BOOKS(null),\n    \n    // Electronics subcategories\n    COMPUTERS(ELECTRONICS),\n    PHONES(ELECTRONICS),\n    CAMERAS(ELECTRONICS),\n    \n    // Clothing subcategories\n    MENS_CLOTHING(CLOTHING),\n    WOMENS_CLOTHING(CLOTHING),\n    KIDS_CLOTHING(CLOTHING);\n    \n    private final ProductCategory parent;\n    \n    ProductCategory(ProductCategory parent) {\n        this.parent = parent;\n    }\n    \n    public ProductCategory getParent() {\n        return parent;\n    }\n    \n    public boolean isMainCategory() {\n        return parent == null;\n    }\n    \n    public boolean isSubcategoryOf(ProductCategory category) {\n        return this.parent == category;\n    }\n}\n\n// Usage\nif (category.isSubcategoryOf(ProductCategory.ELECTRONICS)) {\n    // Handle electronics subcategory\n}\n\n// Find all subcategories\npublic Set<ProductCategory> getSubcategories(ProductCategory parent) {\n    return EnumSet.allOf(ProductCategory.class).stream()\n        .filter(c -> c.isSubcategoryOf(parent))\n        .collect(Collectors.toSet());\n}\n```"
            },
            {
              "title": "EnumSet and EnumMap",
              "description": "```java\n// EnumSet - optimized Set for enums\n\n// Create a set of specific categories\nEnumSet<ProductCategory> taxExemptCategories = EnumSet.of(\n    ProductCategory.BOOKS,\n    ProductCategory.GROCERY\n);\n\n// Check membership (very efficient)\nboolean isTaxExempt = taxExemptCategories.contains(product.getCategory());\n\n// EnumMap - optimized Map with enum keys\nEnumMap<ProductCategory, DiscountStrategy> discountsByCategory =\n    new EnumMap<>(ProductCategory.class);\n\ndiscountsByCategory.put(ProductCategory.ELECTRONICS, new PercentageDiscount(0.05));\ndiscountsByCategory.put(ProductCategory.CLOTHING, new SeasonalDiscount());\n\n// Apply the right discount strategy\nDiscountStrategy strategy = discountsByCategory.get(product.getCategory());\ndouble discountedPrice = strategy.applyDiscount(product.getPrice());\n\n// Both EnumSet and EnumMap are more efficient than HashSet/HashMap\n// because they're backed by arrays indexed by the enum's ordinal\n```"
            }
          ]
        },
        {
          "category": "Advanced",
          "points": [
            {
              "title": "Strategy Pattern Implementation",
              "description": "```java\n// Elegant strategy pattern with enums\npublic enum ProductCategory {\n    ELECTRONICS {\n        @Override\n        public double calculateShipping(Product product, Address destination) {\n            double base = 5.99;\n            // Higher shipping cost for heavier electronics\n            return base + (product.getWeight() * 0.5);\n        }\n        \n        @Override\n        public List<String> getRequiredAttributes() {\n            return Arrays.asList(\"brand\", \"model\", \"warranty\", \"voltage\");\n        }\n    },\n    \n    CLOTHING {\n        @Override\n        public double calculateShipping(Product product, Address destination) {\n            // Flat rate shipping for clothing + weight surcharge\n            return 3.99 + (product.getWeight() * 0.1);\n        }\n        \n        @Override\n        public List<String> getRequiredAttributes() {\n            return Arrays.asList(\"size\", \"color\", \"material\", \"care\");\n        }\n    },\n    \n    BOOKS {\n        @Override\n        public double calculateShipping(Product product, Address destination) {\n            // Books have media mail rate\n            return 2.99 + (product.getWeight() * 0.2);\n        }\n        \n        @Override\n        public List<String> getRequiredAttributes() {\n            return Arrays.asList(\"isbn\", \"author\", \"publisher\", \"edition\");\n        }\n    };\n    \n    // Abstract methods (strategies) all categories must implement\n    public abstract double calculateShipping(Product product, Address destination);\n    public abstract List<String> getRequiredAttributes();\n}\n\n// Usage\ndouble shippingCost = product.getCategory().calculateShipping(product, customerAddress);\nList<String> required = product.getCategory().getRequiredAttributes();\n```"
            },
            {
              "title": "Database and Serialization Integration",
              "description": "```java\n// JPA entity with enum category\n@Entity\npublic class Product {\n    @Id\n    private Long id;\n    \n    private String name;\n    \n    // Store as string in database (more readable)\n    @Enumerated(EnumType.STRING)\n    private ProductCategory category;\n    \n    // Or store as integer for efficiency (less readable)\n    // @Enumerated(EnumType.ORDINAL)\n    // private ProductCategory category;\n}\n\n// Repository queries\npublic interface ProductRepository extends JpaRepository<Product, Long> {\n    // Query by category\n    List<Product> findByCategory(ProductCategory category);\n    \n    // Query by multiple categories\n    List<Product> findByCategoryIn(Collection<ProductCategory> categories);\n}\n\n// JSON serialization with Jackson (defaults to name)\n{\n    \"id\": 1,\n    \"name\": \"Smartphone\",\n    \"category\": \"ELECTRONICS\"\n}\n\n// Custom JSON serialization\npublic enum ProductCategory {\n    ELECTRONICS(\"Electronics\"),\n    CLOTHING(\"Clothing\"),\n    BOOKS(\"Books\");\n    \n    private final String displayName;\n    \n    ProductCategory(String displayName) {\n        this.displayName = displayName;\n    }\n    \n    @JsonValue  // Use this for serialization\n    public String getDisplayName() {\n        return displayName;\n    }\n    \n    // For deserialization\n    @JsonCreator\n    public static ProductCategory fromDisplayName(String displayName) {\n        for (ProductCategory category : values()) {\n            if (category.displayName.equals(displayName)) {\n                return category;\n            }\n        }\n        throw new IllegalArgumentException(\"Unknown category: \" + displayName);\n    }\n}\n```"
            },
            {
              "title": "Internationalization",
              "description": "```java\n// Support for internationalization with enums\npublic enum ProductCategory {\n    ELECTRONICS,\n    CLOTHING,\n    BOOKS,\n    GROCERY;\n    \n    // Get localized name from resource bundle\n    public String getLocalizedName(Locale locale) {\n        ResourceBundle bundle = ResourceBundle.getBundle(\"categories\", locale);\n        String key = \"category.\" + name().toLowerCase();\n        return bundle.getString(key);\n    }\n}\n\n// Resource bundles\n// categories_en.properties\ncategory.electronics=Electronics\ncategory.clothing=Clothing\ncategory.books=Books\n\n// categories_es.properties\ncategory.electronics=Electrónica\ncategory.clothing=Ropa\ncategory.books=Libros\n\n// Usage\nString localizedName = product.getCategory().getLocalizedName(userLocale);\n\n// For UI display\npublic void buildCategoryDropdown(Locale locale) {\n    for (ProductCategory category : ProductCategory.values()) {\n        String displayName = category.getLocalizedName(locale);\n        dropdown.addItem(displayName, category);\n    }\n}\n```"
            },
            {
              "title": "Runtime Category Discovery",
              "description": "```java\n// Dynamic discovery of enum properties\n\n// Reflection to get all enum values\npublic List<Map<String, Object>> getCategoryInfo() {\n    List<Map<String, Object>> result = new ArrayList<>();\n    for (ProductCategory category : ProductCategory.values()) {\n        Map<String, Object> categoryInfo = new HashMap<>();\n        categoryInfo.put(\"id\", category.name());\n        categoryInfo.put(\"displayName\", category.getDisplayName());\n        categoryInfo.put(\"taxRate\", category.getTaxRate());\n        categoryInfo.put(\"department\", category.getDepartment());\n        result.add(categoryInfo);\n    }\n    return result;\n}\n\n// Lookup enum by name\npublic ProductCategory getCategoryByName(String name) {\n    try {\n        return ProductCategory.valueOf(name.toUpperCase());\n    } catch (IllegalArgumentException e) {\n        throw new CategoryNotFoundException(\"Unknown category: \" + name);\n    }\n}\n\n// Typed constant lookup without hardcoding\npublic <T extends Enum<T>> T getEnumConstant(Class<T> enumClass, String name) {\n    return Enum.valueOf(enumClass, name);\n}\n\n// Usage\nProductCategory category = getEnumConstant(ProductCategory.class, \"BOOKS\");\n```"
            }
          ]
        }
      ]
    }
  ]
}